-- @path CitySensing=/ATLProva/CitySensing.ecore
-- @path SocialResource=/ATLProva/SocialResource.ecore
-- @path City=/ATLProva/City.ecore

--- CAMBIARE MM PER NUMPOSTLANG E METTERE COME CONTENIMENTO LA METRICA. 

module GenerateCitySensingNico;
create OUT: CitySensing from IN: SocialResource, IN2: City;


helper context SocialResource!Post def: isInDistrict(d : City!District) : Boolean =
	if d.coordBx <= self.place.coordinates.coordx and d.coordEx > self.place.coordinates.coordx
		and d.coordBy <= self.place.coordinates.coordy and d.coordEy > self.place.coordinates.coordy
	then
		true
	else
		false
	endif;

helper context SocialResource!Post def: isInLocation(d : City!Place) : Boolean =
	--- If the place's name is in the location or it's in the tags
	if self.place.location.name = d.name or self.text.tags -> select(p | p.text = d.name).size() > 0
	then
		true
	else
		false
	endif;

helper context SocialResource!Post def: hasText() : Boolean =
	if not self.text.oclIsUndefined()
	then
		true
	else
		false
	endif;

helper context SocialResource!Post def: hasCoordinates() : Boolean =
	if not self.place.coordinates.oclIsUndefined()
	then
		true
	else
		false
	endif;

helper context SocialResource!Post def: hasTime(): Boolean =
	if not self.time.oclIsUndefined()
	then
		true
	else
		false
	endif;

helper context SocialResource!Post def: hasLocation(): Boolean =
	if not self.place.location.oclIsUndefined()
	then
		true
	else
		false
	endif;

helper context SocialResource!Post def: hasPlace(): Boolean =
	if not self.place.oclIsUndefined()
	then
		true
	else
		false
	endif;
				
helper context City!District def: countPostsDistrict(mr : SocialResource!SocialMediaResource) : Real =
	let lp : OrderedSet(SocialResource!Post) = 
		mr.posts -> select(p | p.hasCoordinates())
	in let
		tp : OrderedSet(SocialResource!Post) = 
		mr.posts -> select(p | not p.hasCoordinates() and p.hasText()) -> select(p | p.text.tags.notEmpty()) 
	in
		lp -> select(e | e.isInDistrict(self)).union(tp -> select(w | w.text.tags.text = self.name)).size();
		
helper context City!Place def: countPostsPlace(mr : SocialResource!SocialMediaResource) : Real =
	mr.posts -> select(p | p.hasPlace()) -> select(p | p.hasLocation())
		-> select(e | e.isInLocation(self)).size();

helper context SocialResource!Post def: hasPicture(): Boolean =
	if self.pictures -> size() > 0
	then
		true
	else
		false
	endif;

--- Actually, it's posts with at least 1 picture, not total of pictures
helper context City!District def: countPicturesDistrict(mr : SocialResource!SocialMediaResource) : Real =
	let pp : OrderedSet(SocialResource!Post) = 
		mr.posts -> select(p | p.hasPicture() and p.hasCoordinates())
	in
		pp -> select(e | e.isInDistrict(self)).size();

helper context City!Place def: countPicturesPlace(mr : SocialResource!SocialMediaResource) : Real =
	mr.posts -> select(p | p.hasPlace()) -> select(p | p.hasPicture() and p.hasLocation()) -> select(e | e.isInLocation(self)).size();
		
helper context City!District def : countPostLangDistrict(mr : SocialResource!SocialMediaResource, l : SocialResource!Languages) : Integer =
	let lp : OrderedSet(SocialResource!Post) = 
		mr.posts -> select(p | p.hasCoordinates())
	in let dp : OrderedSet(SocialResource!Post) = 
		lp -> select(e | e.isInDistrict(self))
	in
		dp -> select(e | e.language.toString() = l.literal.toString()).size();

helper context City!Place def : countPostLangPlace(mr : SocialResource!SocialMediaResource, l : SocialResource!Languages) : Integer =
	mr.posts -> select(p | p.hasPlace()) -> select(p | p.hasLocation())
		-> select(e | e.isInLocation(self))
		-> select(e | e.language.toString() = l.literal.toString()).size();
		
helper context City!District def : countPostTimeSlotDistrict(mr : SocialResource!SocialMediaResource, l : CitySensing!TimeSlots) : Integer =
	let lp : OrderedSet(SocialResource!Post) = 
		mr.posts -> select(p | p.hasCoordinates() and p.hasTime())
	in let dp : OrderedSet(SocialResource!Post) = 
		lp -> select(e | e.isInDistrict(self))
	in
	--- Qui resta hardcoded..
		if l.literal.toString() = 'Morning' then
			dp -> select(e | 4 <= e.time.getHours() and 12 > e.time.getHours()).size()
		else if l.literal.toString() = 'Afternoon' then
			dp -> select(e | 12 <= e.time.getHours() and 18 > e.time.getHours()).size()
		else if l.literal.toString() = 'Evening' then
			dp -> select(e | 18 <= e.time.getHours() and 22 > e.time.getHours()).size()
		else if l.literal.toString() = 'Night' then
			dp -> select(e | 22 <= e.time.getHours() and 24 > e.time.getHours() or 
				0 <= e.time.getHours() and 4 > e.time.getHours()).size()
		else 0 --- Sarebbe un errore
		endif
		endif
		endif
		endif
;

---AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
helper context City!Place def : countPostTimeSlotPlace(mr : SocialResource!SocialMediaResource, l : CitySensing!TimeSlots) : Integer =
	let dp : OrderedSet(SocialResource!Post) = 
		mr.posts -> select(p | p.hasPlace() and p.hasTime()) -> select(p | p.hasLocation()) ->
		select(p | p.isInLocation(self))
	in
	--- Qui resta hardcoded..
		if l.literal.toString() = 'Morning' then
			dp -> select(e | 4 <= e.time.getHours() and 12 > e.time.getHours()).size()
		else if l.literal.toString() = 'Afternoon' then
			dp -> select(e | 12 <= e.time.getHours() and 18 > e.time.getHours()).size()
		else if l.literal.toString() = 'Evening' then
			dp -> select(e | 18 <= e.time.getHours() and 22 > e.time.getHours()).size()
		else if l.literal.toString() = 'Night' then
			dp -> select(e | 22 <= e.time.getHours() and 24 > e.time.getHours() or 
				0 <= e.time.getHours() and 4 > e.time.getHours()).size()
		else 0 --- Sarebbe un errore
		endif
		endif
		endif
		endif
;
		

rule City2MonitoredCity {
	
	from
		s: City!City,
		p: SocialResource!SocialMediaResource
		
	to 
		t: CitySensing!MonitoredCity (
			name <- s.name,
			districts <- s.districts
			
				--- LEO: Crea nuove rule che si chiamano come quelle nella sequence e operano a livello di city
				--- tipo: lazy rule Post2NumPostsCity{ from... to... }
				--- praticamente copia gli equivalenti a livello district e cambia le condizioni qua e lÃ 
				
			--- stats <- Sequence{thisModule.Post2NumPostsCity(s, p)} --- Parti da questa
			---		, thisModule.Post2NumPhotoCity(s, p), thisModule.Post2NumPostLangCity(s, p),
			---	thisModule.Post2NumPostTimeSlotCity(s, p)}
		)
	
}

rule District2MonitoredDistrict {
	
	from
		s: City!District,
		p: SocialResource!SocialMediaResource
		
	to
		t: CitySensing!District (
			name <- s.name,
			coordBx <- s.coordBx,
			coordBy <- s.coordBy,
			coordEx <- s.coordEx,
			coordEy <- s.coordEy,
			places <- s.places,
			stats <- Sequence{thisModule.Post2NumPostsDist(s, p), thisModule.Post2NumPhotoDist(s, p), thisModule.Post2NumPostLangDist(s, p),
				thisModule.Post2NumPostTimeSlotDist(s, p)}
		)
	
}

rule Place2MonitoredPlace {
	
	from
		s: City!Place,
		p: SocialResource!SocialMediaResource
		
	to
		t: CitySensing!Place (
			name <- s.name,
			stats <- Sequence{ thisModule.Post2NumPostsPlace(s, p), thisModule.Post2NumPhotoPlace(s, p), 
					thisModule.Post2NumPostLangPlace(s, p), thisModule.Post2NumPostTimeSlotPlace(s, p) }
		)
	
}

lazy rule Post2NumPostsDist {
	
	from
		s: City!District,
		p: SocialResource!SocialMediaResource
	to
		t: CitySensing!NumPost (
			name <- '#Posts',
			metric <- s.countPostsDistrict(p).longValue()
		)
	
}

lazy rule Post2NumPostsPlace {
	
	from
		s: City!Place,
		p: SocialResource!SocialMediaResource
	to
		t: CitySensing!NumPost (
			name <- '#Posts',
			metric <- s.countPostsPlace(p).longValue()
		)
	
}

lazy rule Post2NumPhotoDist {
	
	from
		s: City!District,
		p: SocialResource!SocialMediaResource
	to
		t: CitySensing!NumPhoto (
			name <- '#Pictures',
			metric <- s.countPicturesDistrict(p).longValue()
		)
	
}

lazy rule Post2NumPhotoPlace {
	
	from
		s: City!Place,
		p: SocialResource!SocialMediaResource
	to
		t: CitySensing!NumPhoto (
			name <- '#Pictures',
			metric <- s.countPicturesPlace(p).longValue()
		)
	
}

lazy rule Post2NumPostTimeSlotDist {
	
	from
		s: City!District,
		p: SocialResource!SocialMediaResource
	to
		t: CitySensing!NumPostTimeSlot (
			name <- '#Posts per time slot',
			postsPerTimeSlot <- CitySensing!TimeSlots.eLiterals 
								-> collect(l | thisModule.Post2MapPostTimeSlotDistrict(s, p, l))
		)
			
}

lazy rule Post2NumPostTimeSlotPlace {
	
	from
		s: City!Place,
		p: SocialResource!SocialMediaResource
	to
		t: CitySensing!NumPostTimeSlot (
			name <- '#Posts per time slot',
			postsPerTimeSlot <- CitySensing!TimeSlots.eLiterals 
								-> collect(l | thisModule.Post2MapPostTimeSlotPlace(s, p, l))
		)
			
}

lazy rule Post2MapPostTimeSlotDistrict {
	
	from
		s: City!District,
		p: SocialResource!SocialMediaResource,
		l: CitySensing!TimeSlots
	to
		t: CitySensing!MapPostTimeSlot (
				key <- l,
				value <- s.countPostTimeSlotDistrict(p, l)
		)
	
}

lazy rule Post2MapPostTimeSlotPlace {
	
	from
		s: City!Place,
		p: SocialResource!SocialMediaResource,
		l: CitySensing!TimeSlots
	to
		t: CitySensing!MapPostTimeSlot (
				key <- l,
				value <- s.countPostTimeSlotPlace(p, l)
		)
	
}

lazy rule Post2NumPostLangDist {
	
	from
		s: City!District,
		p: SocialResource!SocialMediaResource
	to
		t: CitySensing!NumPostLang (
			name <- '#Posts per language',
			langNumber <- SocialResource!Languages.eLiterals 
						-> collect(l | thisModule.Post2MapPostLangDistrict(s, p, l))
		)
			
}

lazy rule Post2NumPostLangPlace {
	
	from
		s: City!Place,
		p: SocialResource!SocialMediaResource
	to
		t: CitySensing!NumPostLang (
			name <- '#Posts per language',
			langNumber <- SocialResource!Languages.eLiterals 
						-> collect(l | thisModule.Post2MapPostLangPlace(s, p, l))
		)
			
}

lazy rule Post2MapPostLangDistrict {
	
	from
		s: City!District,
		p: SocialResource!SocialMediaResource,
		l: SocialResource!Languages
	to
		t: CitySensing!MapPostLang (
				key <- l,
				value <- s.countPostLangDistrict(p, l)
		)
	
}

lazy rule Post2MapPostLangPlace {
	
	from
		s: City!Place,
		p: SocialResource!SocialMediaResource,
		l: SocialResource!Languages
	to
		t: CitySensing!MapPostLang (
				key <- l,
				value <- s.countPostLangPlace(p, l)
		)
	
}
















