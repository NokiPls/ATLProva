-- @path CitySensing=/ATLProva/CitySensing.ecore
-- @path SocialResource=/ATLProva/SocialResource.ecore
-- @path City=/ATLProva/City.ecore

--- CAMBIARE MM PER NUMPOSTLANG E METTERE COME CONTENIMENTO LA METRICA. 

module GenerateCitySensingNico;
create OUT: CitySensing from IN: SocialResource, IN2: City;


helper context SocialResource!Post def: isInDistrict(d : City!District) : Boolean =
	if d.coordBx < self.place.coordinates.coordx and d.coordEx > self.place.coordinates.coordx
		and d.coordBy < self.place.coordinates.coordy and d.coordEy > self.place.coordinates.coordy
	then
		true
	else
		false
	endif;

helper context SocialResource!Post def: isInPlace(d : City!Place) : Boolean =
	if self.place.location.name = d.name
	then
		true
	else
		false
	endif;

helper context SocialResource!Post def: hasCoordinates(): Boolean =
	if not self.place.coordinates.oclIsUndefined()
	then
		true
	else
		false
	endif;

helper context SocialResource!Post def: hasTime(): Boolean =
	if not self.time.oclIsUndefined()
	then
		true
	else
		false
	endif;

helper context SocialResource!Post def: hasLocation(): Boolean =
	if self.place.location -> size() > 0
	then
		true
	else
		false
	endif;
				
helper context City!District def: countPostsDistrict(mr : SocialResource!SocialMediaResource) : Real =
	let lp : OrderedSet(SocialResource!Post) = 
		mr.posts -> select(p | p.hasCoordinates())
	in
		if lp -> select(e | e.isInDistrict(self)).isEmpty() then
			0
		else
			lp -> select(e | e.isInDistrict(self)).size()
		endif;
		
helper context City!Place def: countPostsPlace(mr : SocialResource!SocialMediaResource) : Real =
	let lp : OrderedSet(SocialResource!Post) = 
		mr.posts -> select(p | p.hasLocation())
	in
		lp -> select(e | e.isInPlace(self)).size();

helper context SocialResource!Post def: hasPicture(): Boolean =
	if self.pictures -> size() > 0
	then
		true
	else
		false
	endif;

--- Actually, it's posts with at least 1 picture, not total of pictures
helper context City!District def: countPictures(mr : SocialResource!SocialMediaResource) : Real =
	let pp : OrderedSet(SocialResource!Post) = 
		mr.posts -> select(p | p.hasPicture() and p.hasCoordinates())
	in
		pp -> select(e | e.isInDistrict(self)).size();

helper context City!Place def: countPictures(mr : SocialResource!SocialMediaResource) : Real =
	let pp : OrderedSet(SocialResource!Post) = 
		mr.posts -> select(p | p.hasPicture() and p.hasLocation())
	in
		pp -> select(e | e.isInPlace(self)).size();

		
helper context City!District def : countPostLangDistrict(mr : SocialResource!SocialMediaResource, l : SocialResource!Languages) : Integer =
	let lp : OrderedSet(SocialResource!Post) = 
		mr.posts -> select(p | p.hasCoordinates())
	in let dp : OrderedSet(SocialResource!Post) = 
		lp -> select(e | e.isInDistrict(self))
	in
		dp -> select(e | e.language.toString() = l.literal.toString()).size();
		
helper context City!District def : countPostTimeSlotDistrict(mr : SocialResource!SocialMediaResource, l : CitySensing!TimeSlots) : Integer =
	let lp : OrderedSet(SocialResource!Post) = 
		mr.posts -> select(p | p.hasCoordinates() and p.hasTime())
	in let dp : OrderedSet(SocialResource!Post) = 
		lp -> select(e | e.isInDistrict(self))
	in
	--- Qui resta hardcoded..
		if l.literal.toString() = 'Morning' then
			dp -> select(e | 4 <= e.time.getHours() and 12 > e.time.getHours()).size()
		else if l.literal.toString() = 'Afternoon' then
			dp -> select(e | 12 <= e.time.getHours() and 18 > e.time.getHours()).size()
		else if l.literal.toString() = 'Evening' then
			dp -> select(e | 18 <= e.time.getHours() and 22 > e.time.getHours()).size()
		else if l.literal.toString() = 'Night' then
			dp -> select(e | 22 <= e.time.getHours() and 24 > e.time.getHours() or 
				0 <= e.time.getHours() and 4 > e.time.getHours()).size()
		else 0 --- Sarebbe un errore
		endif
		endif
		endif
		endif
		;
		

rule City2MonitoredCity {
	
	from
		s: City!City,
		p: SocialResource!SocialMediaResource
		
	to 
		t: CitySensing!MonitoredCity (
			name <- s.name,
			districts <- s.districts,
			
				--- LEO: Crea nuove rule che si chiamano come quelle nella sequence e operano a livello di city
				--- tipo: lazy rule Post2NumPostsCity{ from... to... }
				--- praticamente copia gli equivalenti a livello district e cambia le condizioni qua e lÃ 
				
			stats <- Sequence{thisModule.Post2NumPostsCity(s, p)} --- Parti da questa
			---		, thisModule.Post2NumPhotoCity(s, p), thisModule.Post2NumPostLangCity(s, p),
			---	thisModule.Post2NumPostTimeSlotCity(s, p)}
		)
	
}

rule District2MonitoredDistrict {
	
	from
		s: City!District,
		p: SocialResource!SocialMediaResource
		
	to
		t: CitySensing!District (
			name <- s.name,
			coordBx <- s.coordBx,
			coordBy <- s.coordBy,
			coordEx <- s.coordEx,
			coordEy <- s.coordEy,
			places <- s.places,
			stats <- Sequence{thisModule.Post2NumPostsDist(s, p), thisModule.Post2NumPhotoDist(s, p), thisModule.Post2NumPostLangDist(s, p),
				thisModule.Post2NumPostTimeSlotDist(s, p)}
		)
	
}

rule Place2MonitoredPlace {
	
	from
		s: City!Place,
		p: SocialResource!SocialMediaResource
		
	to
		t: CitySensing!Place (
			name <- s.name,
			categories <- s.categories
	---		stats <- Sequence{thisModule.Post2NumPostsPlace(s, p), thisModule.Post2NumPhotoPlace(s, p), thisModule.Post2NumPostLangPlace(s, p)
				--- thisModule.Post2MorningPostDist()
			---	}
		)
	
}

rule Category2MonitoredCategory {
	
	from
		s: City!Category
		
	to
		t: CitySensing!Category (
			type <- s.type
		)
		
}

lazy rule Post2NumPostsDist {
	
	from
		s: City!District,
		p: SocialResource!SocialMediaResource
	to
		t: CitySensing!NumPost (
			name <- '#Posts',
			metric <- s.countPostsDistrict(p).longValue()
		)
	
}

lazy rule Post2NumPostsPlace {
	
	from
		s: City!Place,
		p: SocialResource!SocialMediaResource
	to
		t: CitySensing!NumPost (
			name <- '#Posts',
			metric <- s.countPostsPlace(p).longValue()
		)
	
}

lazy rule Post2NumPhotoDist {
	
	from
		s: City!District,
		p: SocialResource!SocialMediaResource
	to
		t: CitySensing!NumPhoto (
			name <- '#Pictures',
			metric <- s.countPictures(p).longValue()
		)
	
}

lazy rule Post2NumPhotoPlace {
	
	from
		s: City!District,
		p: SocialResource!SocialMediaResource
	to
		t: CitySensing!NumPhoto (
			name <- '#Pictures',
			metric <- s.countPictures(p).longValue()
		)
	
}

lazy rule Post2NumPostTimeSlotDist {
	
	from
		s: City!District,
		p: SocialResource!SocialMediaResource
	to
		t: CitySensing!NumPostTimeSlot (
			name <- '#Posts per time slot',
			postsPerTimeSlot <- CitySensing!TimeSlots.eLiterals -> collect(l | thisModule.Post2MapPostTimeSlotDistrict(s, p, l))
		)
			
}

lazy rule Post2MapPostTimeSlotDistrict {
	
	from
		s: City!District,
		p: SocialResource!SocialMediaResource,
		l: CitySensing!TimeSlots
	to
		t: CitySensing!MapPostTimeSlot (
				key <- l,
				value <- s.countPostTimeSlotDistrict(p, l)
		)
	
}

lazy rule Post2NumPostLangDist {
	
	from
		s: City!District,
		p: SocialResource!SocialMediaResource
	to
		t: CitySensing!NumPostLang (
			name <- '#Posts per language',
			langNumber <- SocialResource!Languages.eLiterals -> collect(l | thisModule.Post2MapPostLangDistrict(s, p, l))
		)
			
}

lazy rule Post2MapPostLangDistrict {
	
	from
		s: City!District,
		p: SocialResource!SocialMediaResource,
		l: SocialResource!Languages
	to
		t: CitySensing!MapPostLang (
				key <- l,
				value <- s.countPostLangDistrict(p, l)
		)
	
}
















